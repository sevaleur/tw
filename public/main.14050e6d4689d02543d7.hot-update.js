/*! For license information please see main.14050e6d4689d02543d7.hot-update.js.LICENSE.txt */
"use strict";self.webpackHotUpdatetraewarren("main",{"./app/shaders/noise/fragment.glsl":(n,e,a)=>{a.r(e),a.d(e,{default:()=>t});const t="#define GLSLIFY 1\nuniform float u_scroll; \nuniform float u_time; \nuniform float u_alpha;\n\nvarying vec2 v_uv; \n\nfloat rand(vec2 n) \n{ \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n      mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n      mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n      return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n  float f = 0.0;\n\n  f += 0.500000*noise( p + (u_scroll + (u_time * 0.25)) ); p = mtx*p*2.02;\n  f += 0.031250*noise( p ); p = mtx*p*2.01;\n  f += 0.250000*noise( p ); p = mtx*p*2.03;\n  f += 0.125000*noise( p ); p = mtx*p*2.01;\n  f += 0.062500*noise( p ); p = mtx*p*2.04;\n  f += 0.015625*noise( p + sin(u_scroll) );\n\n  return f/0.96875;\n}\n\nfloat pattern( vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid main()\n{\n  vec4 jungleGreen = vec4(0.082, 0.145, 0.176, u_alpha);\n  vec4 aerospaceOrange = vec4(0.988, 0.322, 0.0, u_alpha); \n  vec4 antiqueWhite = vec4(1.,0.918,0.859, u_alpha);\n\n  float shade = pattern(v_uv); \n\n  vec4 final = mix(antiqueWhite, aerospaceOrange, shade * (u_scroll * 0.5));\n\n  gl_FragColor = final;\n}"}},(function(n){n.h=()=>"64e9db0cdfe5e8b5d801"}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi4xNDA1MGU2ZDQ2ODlkMDI1NDNkNy5ob3QtdXBkYXRlLmpzIiwibWFwcGluZ3MiOiI7aUlBQUEsaTBDQ0FBQSxFQUFvQkMsRUFBSSxJQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZXdhcnJlbi8uL2FwcC9zaGFkZXJzL25vaXNlL2ZyYWdtZW50Lmdsc2wiLCJ3ZWJwYWNrOi8vdHJhZXdhcnJlbi93ZWJwYWNrL3J1bnRpbWUvZ2V0RnVsbEhhc2giXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIEdMU0xJRlkgMVxcbnVuaWZvcm0gZmxvYXQgdV9zY3JvbGw7IFxcbnVuaWZvcm0gZmxvYXQgdV90aW1lOyBcXG51bmlmb3JtIGZsb2F0IHVfYWxwaGE7XFxuXFxudmFyeWluZyB2ZWMyIHZfdXY7IFxcblxcbmZsb2F0IHJhbmQodmVjMiBuKSBcXG57IFxcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChuLCB2ZWMyKDEyLjk4OTgsIDQuMTQxNCkpKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG5cXG5mbG9hdCBub2lzZSh2ZWMyIHApXFxue1xcbiAgICB2ZWMyIGlwID0gZmxvb3IocCk7XFxuICAgIHZlYzIgdSA9IGZyYWN0KHApO1xcbiAgICB1ID0gdSp1KigzLjAtMi4wKnUpO1xcblxcbiAgICBmbG9hdCByZXMgPSBtaXgoXFxuICAgICAgbWl4KHJhbmQoaXApLHJhbmQoaXArdmVjMigxLjAsMC4wKSksdS54KSxcXG4gICAgICBtaXgocmFuZChpcCt2ZWMyKDAuMCwxLjApKSxyYW5kKGlwK3ZlYzIoMS4wLDEuMCkpLHUueCksdS55KTtcXG4gICAgICByZXR1cm4gcmVzKnJlcztcXG59XFxuXFxuY29uc3QgbWF0MiBtdHggPSBtYXQyKCAwLjgwLCAgMC42MCwgLTAuNjAsICAwLjgwICk7XFxuXFxuZmxvYXQgZmJtKCB2ZWMyIHAgKVxcbntcXG4gIGZsb2F0IGYgPSAwLjA7XFxuXFxuICBmICs9IDAuNTAwMDAwKm5vaXNlKCBwICsgKHVfc2Nyb2xsICsgKHVfdGltZSAqIDAuMjUpKSApOyBwID0gbXR4KnAqMi4wMjtcXG4gIGYgKz0gMC4wMzEyNTAqbm9pc2UoIHAgKTsgcCA9IG10eCpwKjIuMDE7XFxuICBmICs9IDAuMjUwMDAwKm5vaXNlKCBwICk7IHAgPSBtdHgqcCoyLjAzO1xcbiAgZiArPSAwLjEyNTAwMCpub2lzZSggcCApOyBwID0gbXR4KnAqMi4wMTtcXG4gIGYgKz0gMC4wNjI1MDAqbm9pc2UoIHAgKTsgcCA9IG10eCpwKjIuMDQ7XFxuICBmICs9IDAuMDE1NjI1Km5vaXNlKCBwICsgc2luKHVfc2Nyb2xsKSApO1xcblxcbiAgcmV0dXJuIGYvMC45Njg3NTtcXG59XFxuXFxuZmxvYXQgcGF0dGVybiggdmVjMiBwIClcXG57XFxuXFx0cmV0dXJuIGZibSggcCArIGZibSggcCArIGZibSggcCApICkgKTtcXG59XFxuXFxudm9pZCBtYWluKClcXG57XFxuICB2ZWM0IGp1bmdsZUdyZWVuID0gdmVjNCgwLjA4MiwgMC4xNDUsIDAuMTc2LCB1X2FscGhhKTtcXG4gIHZlYzQgYWVyb3NwYWNlT3JhbmdlID0gdmVjNCgwLjk4OCwgMC4zMjIsIDAuMCwgdV9hbHBoYSk7IFxcbiAgdmVjNCBhbnRpcXVlV2hpdGUgPSB2ZWM0KDEuLDAuOTE4LDAuODU5LCB1X2FscGhhKTtcXG5cXG4gIGZsb2F0IHNoYWRlID0gcGF0dGVybih2X3V2KTsgXFxuXFxuICB2ZWM0IGZpbmFsID0gbWl4KGFudGlxdWVXaGl0ZSwgYWVyb3NwYWNlT3JhbmdlLCBzaGFkZSAqICh1X3Njcm9sbCAqIDAuNSkpO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gZmluYWw7XFxufVwiOyIsIl9fd2VicGFja19yZXF1aXJlX18uaCA9ICgpID0+IChcIjY0ZTlkYjBjZGZlNWU4YjVkODAxXCIpIl0sIm5hbWVzIjpbIl9fd2VicGFja19yZXF1aXJlX18iLCJoIl0sInNvdXJjZVJvb3QiOiIifQ==